using System;

namespace RhoMicro.PlumberNet.Generator;

using System.Globalization;
using System.Runtime.CompilerServices;
using CodeAnalysis.Lyra;
using Microsoft.CodeAnalysis;
using static RhoMicro.CodeAnalysis.Lyra.ComponentFactory.Docs;

[Generator(LanguageNames.CSharp)]
public class PlumberNetGenerator : IIncrementalGenerator
{
    private const Int32 _maxArity = 16;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
        {
            var builder = new CSharpSourceBuilder(new CSharpSourceBuilderOptions()
            {
                Prelude = (b, _) => b.AppendLine($"""
                                                  // <auto-generated>
                                                  // This file was generated using the {typeof(PlumberNetGenerator)}.
                                                  // </auto-generated>
                                                  #pragma warning disable
                                                  // SPDX-License-Identifier: MPL-2.0

                                                  namespace RhoMicro.PlumberNet;

                                                  """)
            }).SetCancellationToken(ctx.CancellationToken);

            AddPipeArguments(builder, ctx);
            AddPipe(builder, ctx);
            AddPlumbing(builder, ctx);
        });
    }

    private static void AddPlumbing(
        CSharpSourceBuilder builder,
        IncrementalGeneratorPostInitializationContext ctx)
    {
        var ct = ctx.CancellationToken;
        ct.ThrowIfCancellationRequested();

        var hintName = "RhoMicro.PlumberNet.Plumbing.g.cs";
        builder.Clear();

        builder.AppendLine(
                $$"""
                  {{Summary("Provides access to pipe entry and exit points, as well as extension methods allowing for pipe syntax.")}}
                  public static class Plumbing
                  {
                      /// {{Summary("""
                                    Gets a pipe terminator in order to mark the beginning or ending of a pipe.
                                    Values piped into the terminator from the left are converted to non-pipe values 
                                    (or tuples) and may "exit" the pipe.
                                    Values piped into the terminator from the right are converted to pipe arguments 
                                    and can be used further in the pipe.
                                    """)}}
                      public static PipeTerminator Pipe => new();

                  """)
            .Indent();

        AppendPipeExtensions(builder, ct);
        AppendPipeArgumentExtensions(builder, ct);

        builder.Detent().AppendLine().Append('}');

        var source = builder.ToString();

        ctx.AddSource(
            hintName: hintName,
            source: source);
    }

    private static void AppendPipeArgumentExtensions(CSharpSourceBuilder builder, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        for (var i = 1; i <= _maxArity; i++)
        {
            ct.ThrowIfCancellationRequested();

            builder.AppendLine().AppendLine();

            AppendPipeArgumentExtensions(i, builder, ct);
        }
    }

    private static void AppendPipeArgumentExtensions(Int32 arity, CSharpSourceBuilder builder, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        var typeParameters = ArityDependentList.CreateTypeParameters(arity);
        var arguments = ArityDependentList.CreateArgumentsArgumentAccessors(arity);
        var minResultArity = arity + 1;
        var minResultArityTypeParameters = ArityDependentList.CreateTypeParameters(minResultArity);
        var minResultValueCardinal = (arity + 1).ToString(CultureInfo.InvariantCulture);

        if (arity < _maxArity)
        {
            builder.Append(
                    $$"""

                      extension<{{minResultArityTypeParameters}}>(PipeArguments<{{typeParameters}}>)
                      {
                      """
                ).Indent()
                .Append(
                    $$"""

                      {{Summary("Adds a value to an instance of pipe arguments.")}}
                      {{Param("arguments", "The arguments to add another value to.")}}
                      {{Param($"value{minResultValueCardinal}", "The value to add to the arguments.")}}
                      {{Returns("A new pipe arguments instance containing all provided arguments.")}}
                      [{{typeof(OverloadResolutionPriorityAttribute)}}(0)]
                      public static PipeArguments<{{minResultArityTypeParameters}}> operator |(PipeArguments<{{typeParameters}}> arguments, T{{minResultValueCardinal}} value{{minResultValueCardinal}})
                          => new({{arguments}}, value{{minResultValueCardinal}});

                      /// {{Summary("Adds a value to an instance of pipe arguments.")}}
                      /// {{Param("arguments", "The arguments to add another value to.")}}
                      /// {{Param("factory", "The factory used to create the value.")}}
                      /// {{Returns("A new pipe arguments instance containing all provided arguments.")}}
                      [{{typeof(OverloadResolutionPriorityAttribute)}}(1)]
                      public static PipeArguments<{{minResultArityTypeParameters}}> operator |(PipeArguments<{{typeParameters}}> arguments, global::System.Func<T{{minResultValueCardinal}}> factory)
                          => new({{arguments}}, factory.Invoke());
                          
                      {{Summary("Projects pipe arguments onto a result type.")}}
                      {{Param("arguments", "The pipe arguments to project.")}}
                      {{Param("projection", "The projection to invoke with the arguments.")}}
                      {{Returns("The result of invoking the projection using the arguments.")}}
                      [{{typeof(OverloadResolutionPriorityAttribute)}}(2)]
                      public static PipeArguments<T{{minResultValueCardinal}}> operator |(PipeArguments<{{typeParameters}}> arguments, global::System.Func<{{minResultArityTypeParameters}}> projection)
                          => new(projection.Invoke({{arguments}}));
                      """)
                .Detent()
                .AppendLine()
                .Append('}');
        }
        else
        {
            builder.Append(
                    $$"""

                      extension<{{minResultArityTypeParameters}}>(PipeArguments<{{typeParameters}}>)
                      {
                      """
                ).Indent()
                .Append(
                    $$"""

                      {{Summary("Projects pipe arguments onto a result type.")}}
                      {{Param("arguments", "The pipe arguments to project.")}}
                      {{Param("projection", "The projection to invoke with the arguments.")}}
                      {{Returns("The result of invoking the projection using the arguments.")}}
                      public static PipeArguments<T{{minResultValueCardinal}}> operator |(PipeArguments<{{typeParameters}}> arguments, global::System.Func<{{minResultArityTypeParameters}}> projection)
                          => new(projection.Invoke({{arguments}}));
                      """)
                .Detent()
                .AppendLine()
                .Append('}');
        }

        for (int resultArity = minResultArity; resultArity <= _maxArity; resultArity++)
        {
            ct.ThrowIfCancellationRequested();

            var additionalArity = resultArity - arity;
            var additionalArguments = ArityDependentList.CreateAdditionalArgumentsArgumentAccessors(additionalArity);
            var resultTypeParameters = ArityDependentList.CreateTypeParameters(resultArity);

            builder.Append(
                $$"""


                  extension<{{resultTypeParameters}}>(PipeArguments<{{typeParameters}}>)
                  {
                      /// {{Summary("Adds additional arguments to an instance of pipe arguments.")}}
                      /// {{Param("arguments", "The arguments to add another value to.")}}
                      /// {{Param("additionalArguments", "The additional arguments to add to the arguments.")}}
                      /// {{Returns("A new pipe arguments instance containing all provided arguments.")}}
                      public static PipeArguments<{{resultTypeParameters}}> operator |(PipeArguments<
                  """);

            var i = 1;
            for (; i <= arity; i++)
            {
                if (i is not 1)
                {
                    builder.Append(", ");
                }

                builder.Append($"T{i}");
            }

            builder.Append("> arguments, PipeArguments<");

            for (; i <= resultArity; i++)
            {
                if (i != minResultArity)
                {
                    builder.Append(", ");
                }

                builder.Append($"T{i}");
            }

            builder.Append(
                $$"""
                  > additionalArguments)
                          => new({{arguments}}, {{additionalArguments}});
                  }
                  """);
        }
    }

    private static void AppendPipeExtensions(CSharpSourceBuilder builder, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        builder.Append(
            $$"""
              extension<TResult>(PipeTerminator)
              {
                  /// {{Summary("Creates a pipe argument from a factory.")}}
                  /// {{Param("pipe", "The pipe to insert the argument into.")}}
                  /// {{Param("factory", "The factory used to create the value.")}}
                  /// {{Returns("The newly created pipe argument.")}}
                  public static PipeArguments<TResult> operator |(PipeTerminator pipe, global::System.Func<TResult> factory)
                      => new(factory.Invoke());
              }

              extension<T1>(PipeTerminator)
              {
                  /// {{Summary("Creates a new pipe by creating the first pipe argument.")}}
                  /// {{Param("pipeTerminator", "The terminator demarking the beginning of the pipe.")}}
                  /// {{Param("value1", "The first value to enter the pipe.")}}
                  /// {{Returns("The newly created pipe argument.")}}
                  public static PipeArguments<T1> operator |(PipeTerminator pipeTerminator, T1 value1)
                      => new(value1);
              }
              """);

        for (var i = 1; i <= _maxArity; i++)
        {
            ct.ThrowIfCancellationRequested();

            var typeParameters = ArityDependentList.CreateTypeParameters(i);

            builder.Append(
                $$"""


                  extension<{{typeParameters}}>(PipeTerminator)
                  {
                      /// {{Summary("Creates a new pipe by adding initial arguments.")}}
                      /// {{Param("pipeTerminator", "The terminator demarking the beginning of the pipe.")}}
                      /// {{Param("arguments", "The initial arguments to enter the pipe.")}}
                      /// {{Returns("The pipe arguments.")}}
                      public static PipeArguments<{{typeParameters}}> operator |(PipeTerminator pipeTerminator, PipeArguments<{{typeParameters}}> arguments)
                          => arguments;
                  }
                  """);
        }
    }

    private static void AddPipe(
        CSharpSourceBuilder builder,
        IncrementalGeneratorPostInitializationContext ctx)
    {
        var ct = ctx.CancellationToken;
        ct.ThrowIfCancellationRequested();

        var hintName = "RhoMicro.PlumberNet.PipeTerminator.g.cs";
        var source = builder
            .Clear()
            .Append($"""
                     {Summary("Represents a pipe terminator, used for opening or closing a pipe.")}
                     public readonly struct PipeTerminator;
                     """)
            .ToString();

        ctx.AddSource(
            hintName: hintName,
            source: source);
    }

    private static void AddPipeArguments(
        CSharpSourceBuilder builder,
        IncrementalGeneratorPostInitializationContext ctx)
    {
        var ct = ctx.CancellationToken;
        ct.ThrowIfCancellationRequested();

        for (var arity = 1; arity <= _maxArity; arity++)
        {
            ct.ThrowIfCancellationRequested();

            builder.Clear();

            var source = builder.Append(new PipeArgumentComponent(arity)).ToString();
            var hintName = $"RhoMicro.PlumberNet.PipeArgument.{arity}.g.cs";

            ctx.AddSource(hintName, source);
        }
    }
}
